# 1769

#s="0001002003004005006007008009011012013014015016017018019021022023024025026027028029031032033034035036037038039041042043044045046047048049051052053054055056057058059061062063064065066067068069071072073074075076077078079081082083084085086087088089091092093094095096097098099111211311411511611711811912212312412512612712812913213313413513613713813914214314414514614714814915215315415515615715815916216316416516616716816917217317417517617717817918218318418518618718818919219319419519619719819922232242252262272282292332342352362372382392432442452462472482492532542552562572582592632642652662672682692732742752762772782792832842852862872882892932942952962972982993334335336337338339344345346347348349354355356357358359364365366367368369374375376377378379384385386387388389394395396397398399444544644744844945545645745845946546646746846947547647747847948548648748848949549649749849955565575585595665675685695765775785795865875885895965975985996667668669677678679687688689697698699777877978878979879988898999001000100100210031004100510061007100810091010110121013"
 #s = "9110234567890"    #10123456789
 s = "10123456789"                      
 #s =  gets.chomp! 
$s = Array.new(1000000,0)  ; $s[0]=-100000 ; res = ""
def marks(s)
   s = s.to_s ;len = s.size
   0.upto(len-1).each {|i|
      1.upto(len-i).each {|j|
         t = s[i,j].to_i ; 
         $s[t] += 1   ;  #p t  
         }
      }
   #s.each_char {|c| $s[c.to_i] += 1}   
end

len = s.length
case len 
when 1..6
   marks(s)
   res = $s.index(0)
   puts res

else
   0.upto(s.length-6).each {|ind| 
      1.upto(5).each {|i| $s[(s[ind,i]).to_i] +=1 } }
      last6 = s[s.length-6,6] ;  marks(last6)
      res = $s.index(0)
      puts res
end
         
   




# 
# a = (Array 1.99999).map(&:to_s)
# 
# flag= true
# a.each {|di| 
#    if !s.include? (di)
#       puts di.to_i  ; flag = false
#       break
#    end
# }


#s="0001002003004005006007008009011012013014015016017018019021022023024025026027028029031032033034035036037038039041042043044045046047048049051052053054055056057058059061062063064065066067068069071072073074075076077078079081082083084085086087088089091092093094095096097098099111211311411511611711811912212312412512612712812913213313413513613713813914214314414514614714814915215315415515615715815916216316416516616716816917217317417517617717817918218318418518618718818919219319419519619719819922232242252262272282292332342352362372382392432442452462472482492532542552562572582592632642652662672682692732742752762772782792832842852862872882892932942952962972982993334335336337338339344345346347348349354355356357358359364365366367368369374375376377378379384385386387388389394395396397398399444544644744844945545645745845946546646746846947547647747847948548648748848949549649749849955565575585595665675685695765775785795865875885895965975985996667668669677678679687688689697698699777877978878979879988898999001000100100210031004100510061007100810091010110121013"

=begin 
I'm laughing now ....
I've spent about 3 hours for this problem.
First off, I used Z-function and I tried to treat problem as a string problem.
 I generated new string and tried to find it. If there is no, that's the answer.

It became not so slow as can seems to be. But TLE#6 got me!


Then I tried to store positions for each digit(0-9) and
 than tried to search target number using binary search for every digit. 
It works, but not good enough to pass test#6.

Then I decided to use the straight approach using bool exists[1000000] 
that indicates whether n is substring. It approach can be done 
since total length is 10^5, so 10^6 is free for sure.

Since we know several approaches sometimes we use more complex first :)
when 2
   a = s[0].to_i ; b = s[1].to_i ; c = s.to_i ; 
   $s[a] += 1 ; $s[b] += 1; $s[c] += 1  
   res = $s.index(0)
   puts res
when 3..5 
   len = s.size
   0.upto(len-1).each {|i|  t = s[i].to_i; $s[t] += 1}
   0.upto(len-2).each {|i|
      (i+1).upto(len-1).each {|j|
         t =s[i..j].to_i ; $s[t] += 1  
         }} 
   res = $s.index(0)
   puts res
=end